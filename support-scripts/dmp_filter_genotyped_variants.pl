#!/usr/bin/perl -w
# dmp_filter_genotyped_variants.pl --- Input is the combined list of variants generated by IMPACT which are also genotyped. This script will filter the variants based on AD, DP, VF and percentage of occurance in other normals regardless of the annotation values. The column locations do not matter as long as column names are as follows:
# Item: ColumnName
# tumorDP: T_TotalDepth
# tumorAD: T_AltCount
# tumorVF: T_AltFreq
# occurance: Occurence_in_Normals
# Author: Zehir <zehira@phoenix-h1>
# Created: 18 Nov 2013
# Version: 0.01

use warnings;
use strict;
use Getopt::Long;
use Cwd;
use MSKCC_DMP_Logger;
use Tie::IxHash;

my ( $input, $hotspots, $titleFile, $DPsnv, $ADsnv, $VFsnv, $DPsnvHS, $ADsnvHS, $VFsnvHS, $DPindel, $ADindel, $VFindel, $DPindelHS, $ADindelHS, $VFindelHS, $occurrencePrcnt, $TNfreqRatioThreshold,
	$clinicalExons, $MAFthreshold );
my $logger = MSKCC_DMP_Logger->get_logger('FILTER VARIANTS BASED ON GENOTYPES');
$logger->start_local();

if (
	@ARGV < 1
	or !GetOptions(
		'input|i:s'                             => \$input,
		'hotspots|h:s'                          => \$hotspots,
		'clinicalExons|ce:s'                    => \$clinicalExons,
		'titleFile|t:s'                         => \$titleFile,
		'minimumDPforSNVs|dp_snv:i'             => \$DPsnv,
		'minimumADforSNVs|ad_snv:i'             => \$ADsnv,
		'minimumVFforSNVs|vf_snv:f'             => \$VFsnv,
		'minimumDPforSNVhotspot|dp_snvHS:i'     => \$DPsnvHS,
		'minimumADforSNVhotspot|ad_snvHS:i'     => \$ADsnvHS,
		'minimumVFforSNVhotspot|vf_snvHS:f'     => \$VFsnvHS,
		'minimumDPforINDELs|dp_indel:i'         => \$DPindel,
		'minimumADforINDELs|ad_indel:i'         => \$ADindel,
		'minimumVFforINDELs|vf_indel:f'         => \$VFindel,
		'minimumDPforINDELhotspot|dp_indelHS:i' => \$DPindelHS,
		'minimumADforINDELhotspot|ad_indelHS:i' => \$ADindelHS,
		'minimumVFforINDELhotspot|vf_indelHS:f' => \$VFindelHS,
		'minimumOccurrencePercent|occurrence:f' => \$occurrencePrcnt,
		'TNfreqRatioThreshold|tn_ratio:i'       => \$TNfreqRatioThreshold,
		'MAFthreshold|mt:f'                     => \$MAFthreshold
	)
  )
{
	Usage();
}
if ( !$input ) {
	$logger->fatal("Input file is missing");
	Usage();
}
if ( !$hotspots ) {
	$logger->fatal("Hotspot file is missing");
	Usage();
}
if ( !$clinicalExons ) {
	$logger->fatal("Clinical exon file is missing");
	Usage();
}
if ( !$titleFile ) {
	$logger->fatal("Title file is missing");
	Usage();
}
if ( !defined $DPsnv ) {
	print "no DPsnv\n";
	$DPsnv = 20;
}
if ( !defined $ADsnv ) {
	print "no ADsnv\n";
	$ADsnv = 10;
}
if ( !defined $VFsnv ) {
	print "no VFsnv\n";
	$VFsnv = 0.05;
}
if ( !defined $DPsnvHS ) {
	print "no DPsnvHS\n";
	$DPsnvHS = 20;
}
if ( !defined $ADsnvHS ) {
	print "no ADsnvHS\n";
	$ADsnvHS = 8;
}
if ( !defined $VFsnvHS ) {
	print "no VFsnvHS\n";
	$VFsnvHS = 0.02;
}
if ( !defined $DPindel ) {
	print "no DPindel\n";
	$DPindel = 20;
}
if ( !defined $ADindel ) {
	print "no ADindel\n";
	$ADindel = 10;
}
if ( !defined $VFindel ) {
	print "no VFindel\n";
	$VFindel = 0.05;
}
if ( !defined $DPindelHS ) {
	print "no DPindelHS\n";
	$DPindelHS = 20;
}
if ( !defined $ADindelHS ) {
	print "no ADindelHS\n";
	$ADindelHS = 8;
}
if ( !defined $VFindelHS ) {
	print "no VFindelHS\n";
	$VFindelHS = 0.02;
}
if ( !defined $occurrencePrcnt ) {
	print "occurance percent\n";
	$occurrencePrcnt = 0.2;
}
if ( !defined $TNfreqRatioThreshold ) {
	print "TNfreg ratio\n";
	$TNfreqRatioThreshold = 5;
}
if ( !defined $MAFthreshold ) {
	print "no MAF thresdhold\n";
	$logger->warn("MAF threshold was not provided, so the default value (0.01) is being used.");
	$MAFthreshold = 0.01;
}
my $outdir = getcwd;

#Get Title file information
my ( $patientIDPerSampleId, $classPerPatientIdSampleId ) = &ReadTitleFile( $titleFile, $outdir );

my %patientIDPerSampleId      = %$patientIDPerSampleId;
my %classPerPatientIdSampleId = %$classPerPatientIdSampleId;

my ( %hotspotExonHash, %hotspotIndelHash, %hotspotHash );
$logger->info("Reading in the hotspots file: $hotspots.");
open HOTSPOT, "<", $hotspots || die $logger->fatal("Can not open $hotspots: $!");
while (<HOTSPOT>) {
	chomp;
	my @line = split("\t");
	next if ( $line[0] eq 'Index' );
	my ( $mut, undef ) = split( " ", $line[2] );
	my $gene = $line[1];
	if ( $mut =~ /fs/ ) {
		my ($mut2) = $mut =~ /([A-Z]\d+fs).*/;
		$hotspotIndelHash{ $gene . ":" . $mut2 } = $mut2;
		print "$gene\t$mut\n" if ( !$mut2 );
	}
	elsif ( $mut =~ />/ ) {
		my ($mut2) = $mut =~ /(.*)\>.*/;
		$hotspotIndelHash{ $gene . ":" . $mut2 } = $mut2;
		print "$gene\t$mut\n" if ( !$mut2 );
	}
	elsif ( $mut =~ /del/ ) {
		my ($mut2) = $mut =~ /(.*)del/;
		$hotspotIndelHash{ $gene . ":" . $mut2 } = $mut2;
		print "$gene\t$mut\n" if ( !$mut2 );
	}
	elsif ( $mut =~ /validation/ ) {
		$mut =~ s/_indel//;

		#$hotspotExonHash{$gene.":".$mut} = $mut;
	}
	elsif ( $mut =~ /ins/ ) {
		$hotspotIndelHash{ $gene . ":" . $mut } = $mut;
	}
	else {
		my ($mut2) = $mut =~ /([A-Z]\d+)\>*[A-Za-z]*.*/;
		if ($mut2) {
			$hotspotHash{ $gene . ":" . $mut2 } = $mut2;
		}
	}
}
close HOTSPOT;

$logger->info("Reading in the clinical exons file: $clinicalExons");
open IN, "<", $clinicalExons || die $!;
while (<IN>) {
	chomp;
	my ( $gene, $exon, $type ) = split("\t");
	$hotspotExonHash{ $gene . ":" . $exon } = $type;

}
close IN;
$logger->info("Starting the filtering of variants.");
my $outputFiltered = $input;
my $outputDropped  = $input;
$outputFiltered =~ s/txt/Filtered.txt/;
$outputDropped  =~ s/txt/Dropped.txt/;
open FILTERED, ">", $outputFiltered || die $logger->fatal("Can not create $outputFiltered: $!");
open DROPPED,  ">", $outputDropped  || die $logger->fatal("Can not create $outputDropped: $!");
open INPUT,    "<", $input          || die $logger->fatal("Can not open $input :$!");
while (<INPUT>) {
	our @header;

	#our ( $DPindex, $ADindex, $VFindex, $occurrenceIndex, $TNfreqRatioIndex, $AAchangeIndex, $exonIndex, $varTypeIndex );
	our (
		$DPindex,       $ADindex,   $VFindex,      $commentsIndex, $occurrenceIndex, $allNormalMedianVFIndex, $TNfreqRatioIndex,
		$AAchangeIndex, $exonIndex, $varTypeIndex, $MAFindex,      $sampleIDindex,   $normalIDindex
	);    #DC
	if (/^Sample/) {
		@header = split( "\t", $_ );
		print FILTERED "$_";
		print DROPPED "$_";
		foreach my $i ( 0 .. scalar(@header) - 1 ) {

			#print "$i\t$header[$i]\n";
			if ( $header[$i] eq "T_TotalDepth" ) {
				$DPindex = $i;
			}
			elsif ( $header[$i] eq "T_AltCount" ) {
				$ADindex = $i;
			}
			elsif ( $header[$i] eq "T_AltFreq" ) {
				$VFindex = $i;
			}
			elsif ( $header[$i] eq "Occurence_in_Normals" ) {
				$occurrenceIndex = $i;
			}
			elsif ( $header[$i] eq "All_N_Median_AlleleFreq" ) {    #DC
				$allNormalMedianVFIndex = $i;
			}
			elsif ( $header[$i] eq "T_freq/All_N_Freq" ) {          # DC
				$TNfreqRatioIndex = $i;
			}
			elsif ( $header[$i] eq "AAchange" ) {
				$AAchangeIndex = $i;
			}
			elsif ( $header[$i] eq "Exon" ) {
				$exonIndex = $i;
			}
			elsif ( $header[$i] eq "VariantClass" ) {
				$varTypeIndex = $i;
			}
			elsif ( $header[$i] eq "1000G_MAF" ) {
				$MAFindex = $i;
			}
			elsif ( $header[$i] eq "Sample" ) {
				$sampleIDindex = $i;
			}
			elsif ( $header[$i] eq "NormalUsed" ) {
				$normalIDindex = $i;
			}
			elsif ( $header[$i] eq "Comments" ) {
				$commentsIndex = $i;
			}
		}
		next;
	}

	#print "$AAchangeIndex\n";

	my @line              = split("\t");
	my $sampleID          = $line[$sampleIDindex];
	my $normalUsed        = $line[$normalIDindex];
	my $ref               = $line[4];
	my $alt               = $line[5];
	my $gene              = $line[7];
	my $DP                = $line[$DPindex];
	my $AD                = $line[$ADindex];
	my $VF                = $line[$VFindex];
	my $allNormalMedianVF = $line[$allNormalMedianVFIndex];
	my $TNfreqRatio       = $line[$TNfreqRatioIndex];
	my $varType           = $line[$varTypeIndex];
	if ( $TNfreqRatio == 0 ) {
		$TNfreqRatio = $TNfreqRatioThreshold;
	}
	my $matched;
	my $patientID = $patientIDPerSampleId{$sampleID};
	my $key = "$normalUsed" . ":" . "$patientID";
	my $tag;

	if ( ( exists $classPerPatientIdSampleId{$key} ) and ( $classPerPatientIdSampleId{$key} =~ /Normal/ ) ) {
		$matched = "Matched";
	}
	else {
		$matched = "Unmatched";
	}
	print "$sampleID\t$normalUsed\t$matched\n";
	my $exon     = $line[$exonIndex];
	my $MAFvalue = $line[$MAFindex];
	if ( !$MAFvalue ) { $MAFvalue = 0; }
	my ( $count, $occurrence ) = split( ";", $line[$occurrenceIndex] );
	

	
	# Filter INDELS
	if ( $matched eq "Matched" ) {    #matched variant calling
		if ( length($ref) > length($alt) || length($ref) < length($alt) ) {

			#if ( exists( $hotspotExonHash{$exon} ) ) { #hotspot exons
			if ( exists( $hotspotExonHash{ $gene . ":" . $exon } ) ) {    #DC: hotspot exons bug

				if (   $DP >= $DPsnvHS
					&& $AD >= $ADsnvHS
					&& $VF >= $VFsnvHS
					&& $occurrence < $occurrencePrcnt
					&& $TNfreqRatio >= $TNfreqRatioThreshold )
				{
					print FILTERED"$_";
				}
				else {
					print DROPPED "$_";
				}
			}
			else {    # novel indel
				if (   $DP >= $DPsnv
					&& $AD >= $ADsnv
					&& $VF >= $VFsnv
					&& $occurrence < $occurrencePrcnt
					&& $TNfreqRatio >= $TNfreqRatioThreshold )
				{
					print FILTERED"$_";
				}
				else {
					print DROPPED "$_";
				}
			}
		}

		# Filter SNVs
		if ( length($ref) == length($alt) && length($ref) == 1 ) {
			my ($aaChange) = $line[$AAchangeIndex] =~ /p\.([A-Z]\d+).*/;
			if ( $varType eq "splicing" || $varType eq "upstream" ) {
				$aaChange = "NA";
			}

			#if ( exists( $hotspotHash{$aaChange} ) ) {    # hotspot mutation
			if ( exists( $hotspotHash{ $gene . ":" . $aaChange } ) ) {    # DC: hotspot mutation bug

				if (   $DP >= $DPsnvHS
					&& $AD >= $ADsnvHS
					&& $VF >= $VFsnvHS
					&& $occurrence < $occurrencePrcnt
					&& $TNfreqRatio >= $TNfreqRatioThreshold )
				{
					print FILTERED "$_";
				}
				else {
					print DROPPED "$_";
				}
			}
			else {    # novel mutation
				if (   $DP >= $DPsnv
					&& $AD >= $ADsnv
					&& $VF >= $VFsnv
					&& $occurrence < $occurrencePrcnt
					&& $TNfreqRatio >= $TNfreqRatioThreshold )
				{
					print FILTERED "$_";
				}
				else {
					print DROPPED "$_";
				}
			}
		}
	}
	else {    # Unmatched variant calling
		if ( length($ref) > length($alt) || length($ref) < length($alt) ) {

			#if ( exists( $hotspotExonHash{$exon} ) ) { #hotspot exons
			if ( exists( $hotspotExonHash{ $gene . ":" . $exon } ) ) {    #DC: hotspot exons bug

				if (   $DP >= $DPsnvHS
					&& $AD >= $ADsnvHS
					&& $VF >= $VFsnvHS
					&& $occurrence < $occurrencePrcnt
					&& $TNfreqRatio >= $TNfreqRatioThreshold )
				{
					print FILTERED"$_";
				}
				else {
					print DROPPED "$_";
				}
			}
			else {    # novel indel
				if (   $DP >= $DPsnv
					&& $AD >= $ADsnv
					&& $VF >= $VFsnv
					&& $occurrence < $occurrencePrcnt
					&& $TNfreqRatio >= $TNfreqRatioThreshold
					&& $MAFvalue < $MAFthreshold )
				{
					print FILTERED"$_";
				}
				else {
					print DROPPED "$_";
				}
			}
		}

		# Filter SNVs
		if ( length($ref) == length($alt) && length($ref) == 1 ) {
			my ($aaChange) = $line[$AAchangeIndex] =~ /p\.([A-Z]\d+).*/;
			if ( $varType eq "splicing" || $varType eq "upstream" ) {
				$aaChange = "NA";
			}
			
			#if ( exists( $hotspotHash{$aaChange} ) ) {    # hotspot mutation
			if ( exists( $hotspotHash{ $gene . ":" . $aaChange } ) ) {    # DC: hotspot mutation bug

				if (   $DP >= $DPsnvHS
					&& $AD >= $ADsnvHS
					&& $VF >= $VFsnvHS
					&& $occurrence < $occurrencePrcnt
					&& $TNfreqRatio >= $TNfreqRatioThreshold )
				{
					print FILTERED "$_";
				}
				else {
					print DROPPED "$_";
				}
			}
			else {    # novel mutation
				if (   $DP >= $DPsnv
					&& $AD >= $ADsnv
					&& $VF >= $VFsnv
					&& $occurrence < $occurrencePrcnt
					&& $TNfreqRatio >= $TNfreqRatioThreshold
					&& $MAFvalue < $MAFthreshold )
				{
					print FILTERED "$_";
				}
				else {
					print DROPPED "$_";
				}
			}
		}
	}
}

#####################################
#####################################
#Read data related to samples as well as barcodes from title file.

sub ReadTitleFile {
	my ( $titleFile, $outdir ) = @_;
	my @barcode      = ();
	my @pool         = ();
	my @sampleId     = ();
	my @collabId     = ();
	my @patientId    = ();
	my @class        = ();
	my @sampleType   = ();
	my @inputNg      = ();
	my @libraryYeild = ();
	my @poolInput    = ();
	my @baitVersion  = ();
	my @fof          = ();
	my @newfof       = ();
	tie( my %patientIDPerSampleID,      'Tie::IxHash' );
	tie( my %classPerPatientIDSampleID, 'Tie::IxHash' );
	open( TFH, $titleFile )
	  || die $logger->fatal("Can not open $titleFile, $!");

	while (<TFH>) {
		next if ( $. == 1 );
		my @dataCols = split( "\t", $_ );
		my @newDatacols =
		  grep( s/\s*$//g, @dataCols );    #remove whitespace if any
		push( @barcode,      $newDatacols[0] );
		push( @pool,         $newDatacols[1] );
		push( @sampleId,     $newDatacols[2] );
		push( @collabId,     $newDatacols[3] );
		push( @patientId,    $newDatacols[4] );
		push( @class,        $newDatacols[5] );
		push( @sampleType,   $newDatacols[6] );
		push( @inputNg,      $newDatacols[7] );
		push( @libraryYeild, $newDatacols[8] );
		push( @poolInput,    $newDatacols[9] );
		push( @baitVersion,  $newDatacols[10] );
	}
	close(TFH);
	for ( my $i = 0 ; $i < scalar(@barcode) ; $i++ ) {

		#print "$[$i] => $class[$i]\n";
		$classPerPatientIDSampleID{ $sampleId[$i] . ":" . $patientId[$i] } = $class[$i];
		$patientIDPerSampleID{ $sampleId[$i] } = $patientId[$i];
	}
	return ( \%patientIDPerSampleID, \%classPerPatientIDSampleID );

}

##############################################
##############################################
sub Usage {
	print "Unknown option: @_\n" if (@_);

	print "\nUsage: perl dmp_filter_genotyped_variants.pl [options]
    [--input|i                                            S  File containing mutations with genotype information (required)]
    [--hotspots|h										  S  File containing the list of hotspots (required)]
    [--clinicalExons|ce									  S  File containing the list of clinical exons (required)]
    [--titleFile|t										  S  Title file (required)]
    [--minimumDPforSNVs|dp_snv                            I  Minumum accepted DP for novel SNVs (default: 20)]
    [--minimumADforSNVs|ad_snv                            I  Minimum accepted AD for novel SNVs (default: 10)]
    [--minimumVFforSNVs|vf_snv                            I  Minimum accepted VF for novel SNVs (default: 0.05)]
    [--minimumDPforSNVhotspot|dp_snvHS                    I  Minumum accepted DP for Hotspot SNVs (default: 20)]
    [--minimumADforSNVhotspot|ad_snvHS                    I  Minimum accepted AD for Hotspot SNVs (default: 8)]
    [--minimumVFforSNVhotspot|vf_snvHS                    I  Minimum accepted VF for Hotspot SNVs (default: 0.02)]
    [--minimumDPforINDELs|dp_indel                        I  Minumum accepted DP for novel INDELs (default: 20)]
    [--minimumADforINDELs|ad_indel                        I  Minimum accepted AD for novel INDELs (default: 10)]
    [--minimumVFforINDELs|vf_indel                        I  Minimum accepted VF for novel INDELs (default: 0.05)]
    [--minimumDPforINDELhotspot|dp_indelHS                I  Minumum accepted DP for Hotspot INDELs (default: 20)]
    [--minimumADforINDELhotspot|ad_indelHS                I  Minimum accepted AD for Hotspot INDELs (default: 8)]
    [--minimumVFforINDELhotspot|vf_indelHS                I  Minimum accepted VF for Hotspot INDELs (default: 0.02)]
    [--minimumOccurrencePercent|occurrence                S  Minimum accepted value of occurrence in other normals, in percent (default: 20)]
    [--TNfreqRatioThreshold|tn_ratio					  S  Minimum value for VFt/VFn value (default: 5)]
    [--MAFthreshold|mt                 					  F Minimum accepted MAF values for unmatched variant calls (default : 0.01)]
    \n";

	exit;
}

__END__

=head1 NAME

dmp_filter_genotyped_variants.pl - Describe the usage of script briefly

=head1 SYNOPSIS

dmp_filter_genotyped_variants.pl [options] args

      -opt --long      Option description

=head1 DESCRIPTION

Stub documentation for dmp_filter_genotyped_variants.pl, 

=head1 AUTHOR

Zehir, E<lt>zehira@phoenix-h1E<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2013 by Zehir

This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.2 or,
at your option, any later version of Perl 5 you may have available.

=head1 BUGS

None reported... yet.

=cut
